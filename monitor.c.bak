#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/kprobes.h>

// 监视的函数名和参数类型
static const char *monitored_function = "sys_clone";

// 函数调用前的钩子函数
static int my_pre_handler(struct kprobe *p, struct pt_regs *regs)
{
    // 获取进程创建时的相关信息，例如进程 ID、父进程 ID 等
    pid_t new_pid = (pid_t)regs->di;
    pid_t new_ppid = current->tgid;

    // 在此处进行进程监视的逻辑判断
    if (strstr(current->comm, "your_process_name") != NULL) {
        // 进程名称匹配，进行相关操作，例如记录日志或发送通知
        printk(KERN_INFO "A process matching the monitored criteria has been created.\n");
        printk(KERN_INFO "New PID: %d, New PPID: %d\n", new_pid, new_ppid);
    }

    return 0;
}

// 内核模块加载时调用的初始化函数
static int __init process_monitor_init(void)
{
    struct kprobe kp = {};

    // 设置监视的函数名
    kp.symbol_name = monitored_function;
    // 设置函数调用前的钩子函数
    kp.pre_handler = my_pre_handler;

    // 注册 Kprobe
    if (register_kprobe(&kp) < 0) {
        printk(KERN_ALERT "Failed to register kprobe.\n");
        return -1;
    }

    printk(KERN_INFO "Process Monitor module loaded.\n");
    return 0;
}

// 内核模块卸载时调用的清理函数
static void __exit process_monitor_exit(void)
{
    struct kprobe kp = {};

    // 取消注册 Kprobe
    kp.symbol_name = monitored_function;
    unregister_kprobe(&kp);

    printk(KERN_INFO "Process Monitor module unloaded.\n");
}

module_init(process_monitor_init);
module_exit(process_monitor_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
